# Dex2

The goal of this level is to drain all the balances of `token1` and `token2` from the `DexTwo` contract, a subtlely modified `Dex` contract from the previous level. The contract's functionality is identical to `Dex`, however, the `swap()` function is slightly altered - it is missing this require statement: `require((from == token1 && to == token2) || (from == token2 && to == token1), "Invalid tokens");`. Removing this require allows for the `from` and `to` arguments to be of any address. Since `DexTwo` still expects the tokens to be ERC20 compliant, given they are wrapped in OpenZeppelin's `IERC20` interface, we can make our own ERC20 tolken to drain the DEX.

In `AttackDex2.sol`, we create our own token contract `ScamToken`, following the `IERC20` interface that we've defined within the file. Remember that this token is for demonstrative purposes and is not meant for use on mainnet - there are clear security vulnerabilities, such as the fact that anyone can mint or burn tokens. For our purposes, we do not care so much about these vulnerabilities as the goal here is not to have an indepth guide on ERC20 tokens but to highlight the dangers of price manipulation in a contract with missing address checks.

To pass this level, we can deploy the `AttackDex2` contract in `AttackDex2.sol` since all functionality occurs within the `constructor()`. In the `constructor()`, we pass in the instance address as the `IDex dex` param. Then, the constructor sets up the `token1` and `token2` tokens from the DEX as well as our own `scamToken1` and `scamToken2`. For both of our scam tokens, we mint 2 tokens keeping 1 and sending the other to the DEX so we have a 1:1 ratio. After approving `scamToken1` and `scamToken2`, we can swap them each once to drain the entire balance of `token1` and `token2`. We only need to send in 1 token as `getSwapAmount()` calculates the amount out as `amount in * 100 / 1`: we divide by 1 since that is the total balance of the dex for the token; we only need to send in 1 token as `1 * 100 / 1 = 100`; and the DEX only holds 100 tokens of `token1` and `token2` respectively.